import { Injectable } from '@nestjs/common';
import { InjectModel } from '@nestjs/sequelize';
import { HttpStatusCode } from 'src/config/config.statuscodes';
import { IJwtSignin } from 'src/interface/interface.payloadjwtsignin';
import { ResponseServer } from 'src/interface/interface.response';
import { Listcours } from 'src/models/model.cours';
import { Messages } from 'src/models/model.messages';
import { Planings } from 'src/models/model.planings';
import { Cours } from 'src/models/model.sessionshascours';
import { AllSercices } from 'src/services/serices.all';
import { MailService } from 'src/services/service.mail';
import { Responder } from 'src/strategy/strategy.responder';
import { CreateCoursDto } from './dto/create-cours.dto';
import { CreatePresetCoursDto } from './dto/create-preset-cours.dto';
import { UpdateCoursFormateursDto } from './dto/update-cours-formateurs.dto';
import { CreationAttributes } from 'sequelize';
import { AddHomeworkSessionDto } from 'src/sessions/dto/add-homework.dto';
import { SeanceSessions } from 'src/models/model.courshasseances';
import { StagiaireHasSession } from 'src/models/model.stagiairehassession';
import { FormateurHasSession } from 'src/models/model.formateurhassession';
import { HomeworksSession } from 'src/models/model.homework';
import { StagiaireHasHomeWork } from 'src/models/model.stagiairehashomeworks';
import { SessionSuivi } from 'src/models/model.suivisession';
import { AssignFormateurToSessionDto } from 'src/sessions/dto/attribute-session.dto';
import { Users } from 'src/models/model.users';
import { CreateDocumentDto } from './dto/create-documents.dto';
import { Documents } from 'src/models/model.documents';
import { CreateCoursContentDto } from './dto/create-cours-content.dto';
import { Chapitre } from 'src/models/model.chapitres';
import { IChapitres } from 'src/interface/interface.cours';
import { CreateEvaluationFullDto } from './dto/create-evaluation.dto';
import { Evaluation } from 'src/models/model.evaluation';
import { Question } from 'src/models/model.quiz';
import { Option } from 'src/models/model.optionsquiz';
import {
  alloedMaterials,
  typeEvaluation,
  typeFormations,
} from 'src/utils/utiles.typesformations';

@Injectable()
export class CoursService {
  constructor(
    private readonly allSercices: AllSercices,
    private readonly mailService: MailService,

    @InjectModel(Messages)
    private readonly messageModel: typeof Messages,

    @InjectModel(Planings)
    private readonly planingModel: typeof Planings,

    @InjectModel(Cours)
    private readonly coursModel: typeof Cours,

    @InjectModel(SeanceSessions)
    private readonly seancesModel: typeof SeanceSessions,

    @InjectModel(SessionSuivi)
    private readonly sessionModel: typeof SessionSuivi,

    @InjectModel(Listcours)
    private readonly listcoursModel: typeof Listcours,

    @InjectModel(Users)
    private readonly usersModel: typeof Users,

    @InjectModel(StagiaireHasSession)
    private readonly hasSessionStudentModel: typeof StagiaireHasSession,

    @InjectModel(FormateurHasSession)
    private readonly hasSessionFormateurModel: typeof FormateurHasSession,

    @InjectModel(HomeworksSession)
    private readonly homeworkModel: typeof HomeworksSession,

    @InjectModel(StagiaireHasHomeWork)
    private readonly hashomeworkModel: typeof StagiaireHasHomeWork,

    @InjectModel(Chapitre)
    private readonly chapitrecoursModel: typeof Chapitre,

    @InjectModel(Documents)
    private readonly docModel: typeof Documents,

    @InjectModel(Evaluation)
    private readonly evaluationModel: typeof Evaluation,

    @InjectModel(Question)
    private readonly questionModel: typeof Question,

    @InjectModel(Option)
    private readonly optionModel: typeof Option,
  ) {}

  async gettypesevaluation(user: IJwtSignin): Promise<ResponseServer> {
    try {
      const types = typeEvaluation;
      return Responder({ status: HttpStatusCode.Ok, data: types });
    } catch (error) {
      return Responder({
        status: HttpStatusCode.InternalServerError,
        data: error,
      });
    }
  }
  async getconditionsevaluation(user: IJwtSignin): Promise<ResponseServer> {
    try {
      const types = typeFormations;
      return Responder({ status: HttpStatusCode.Ok, data: types });
    } catch (error) {
      return Responder({
        status: HttpStatusCode.InternalServerError,
        data: error,
      });
    }
  }
  async getallowedmatosevaluation(user: IJwtSignin): Promise<ResponseServer> {
    try {
      const types = alloedMaterials;
      return Responder({ status: HttpStatusCode.Ok, data: types });
    } catch (error) {
      return Responder({
        status: HttpStatusCode.InternalServerError,
        data: error,
      });
    }
  }
  async deleteEvaluation(
    user: IJwtSignin,
    idevaluation: number,
  ): Promise<ResponseServer> {
    try {
      const evaluation = await this.evaluationModel.findOne({
        where: {
          id: idevaluation,
        },
      });
      if (!evaluation)
        return Responder({
          status: HttpStatusCode.NotFound,
          data: 'The evaluation with ID not found in the list',
        });
      return evaluation
        .destroy()
        .then((_) =>
          Responder({
            status: HttpStatusCode.Ok,
            data: 'The evaluation has been deleted successfully',
          }),
        )
        .catch((err) =>
          Responder({ status: HttpStatusCode.InternalServerError, data: err }),
        );
    } catch (error) {
      return Responder({
        status: HttpStatusCode.InternalServerError,
        data: error,
      });
    }
  }
  async getEvaluationById(idevaluation: number): Promise<ResponseServer> {
    try {
      return this.evaluationModel
        .findOne({
          where: {
            id: idevaluation,
          },
          attributes: {
            exclude: ['createdAt', 'updatedAt', 'id_cours'],
          },
          include: [
            {
              model: Question,
              required: false,
              attributes: ['id', 'content', 'type'],
              include: [
                {
                  model: Option,
                  required: false,
                  attributes: ['id', 'text', 'is_correct'],
                },
              ],
            },
          ],
        })
        .then((evaluation) => {
          if (evaluation instanceof Evaluation) {
            return Responder({ status: HttpStatusCode.Ok, data: evaluation });
          } else
            return Responder({
              status: HttpStatusCode.NotFound,
              data: 'The item can not be found with the specifique ID',
            });
        })
        .catch((err) =>
          Responder({ status: HttpStatusCode.InternalServerError, data: err }),
        );
    } catch (error) {
      return Responder({
        status: HttpStatusCode.InternalServerError,
        data: error,
      });
    }
  }
  async getEvaluationsByCours(
    idcours: number,
    idsession: number,
  ): Promise<ResponseServer> {
    try {
      return this.evaluationModel
        .findAll({
          where: {
            id_cours: idcours,
            id_session: idsession,
          },
          attributes: {
            exclude: ['createdAt', 'updatedAt', 'id_cours'],
          },
          include: [
            {
              model: Question,
              required: false,
              attributes: ['id', 'content', 'type'],
              include: [
                {
                  model: Option,
                  required: false,
                  attributes: ['id', 'text'],
                },
              ],
            },
          ],
        })
        .then((list) =>
          Responder({
            status: HttpStatusCode.Ok,
            data: { length: list.length, rows: list },
          }),
        )
        .catch((err) =>
          Responder({ status: HttpStatusCode.InternalServerError, data: err }),
        );
    } catch (error) {
      return Responder({
        status: HttpStatusCode.InternalServerError,
        data: error,
      });
    }
  }
  async addEvaluationToCours(
    user: IJwtSignin,
    createEvaluationDto: CreateEvaluationFullDto,
  ): Promise<ResponseServer> {
    const {
      id_cours,
      title,
      description,
      estimatedDuration,
      score,
